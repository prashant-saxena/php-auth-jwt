<?php

defined('SECRET_KEY') or define('SECRET_KEY', '4cd37737dd25a788eee4148ba8d2946e30630bd0227172294e10d65cedc64adc');

function random_token($length){
    
    if (function_exists('random_bytes')) {
        return bin2hex(random_bytes($length));
    }
    
    if (function_exists('mcrypt_create_iv')) {
        return bin2hex(mcrypt_create_iv($length, MCRYPT_DEV_URANDOM));
    }
    
    if (function_exists('openssl_random_pseudo_bytes')) {
        return bin2hex(openssl_random_pseudo_bytes($length));
    }
}

function create_json_web_token($payload)
{
    date_default_timezone_set('Asia/Calcutta');
    $payload['iat'] = time(); // Issued at: time when the token was generated
    $payload['exp'] = time() + 20; // Expire
    $payload['iss'] = $_SERVER['SERVER_NAME']; // Issuer
    //$payload['jti'] = 'some id'; // Json Token Id: an unique identifier for the token
    //$payload['nbf'] = // Not before
    
    // header
    $header = array("alg"=>"HS256","typ"=>"JWT");
    
    // json encoded header
    $json_encoded_header = json_encode($header);
    
    // base64 encodes the header json
    $encoded_header = base64_encode($json_encoded_header);
        
    // json encoded payload
    $json_encoded_payload = json_encode($payload);
    
    // base64 encodes the payload json
    $encoded_payload = base64_encode($json_encoded_payload);

    // base64 strings are concatenated to one that looks like this
    $header_payload = $encoded_header . '.' . $encoded_payload;

    //Setting the secret key
    //$rb = random_token(8);
    //$secret_key = bin2hex($rb);
    //echo $secret_key;

    // Creating the signature, a hash with the s256 algorithm and the secret key. The signature is also base64 encoded.
    $signature = base64_encode(hash_hmac('sha256', $header_payload, SECRET_KEY, true));

    // Creating the JWT token by concatenating the signature with the header and payload, that looks like this:
    $jwt_token = $header_payload . '.' . $signature;

    // Make sure to encode token. It may have '+' sign. By the time of reading
    // $_COOKIE['value'] decode it again using rawurldecode or else '+' will
    // become an ' ' space.
    return rawurlencode($jwt_token);

}


function validate_json_web_token($jwt_token)
{
    rawurldecode($jwt_token);
    
    // Split a string by '.' 
    $jwt_values = explode('.', $jwt_token);

    // extracting the signature from the original JWT 
    $recieved_signature = $jwt_values[2];

    // concatenating the first two arguments of the $jwt_values array, representing the header and the payload
    $recievedHeaderAndPayload = $jwt_values[0] . '.' . $jwt_values[1];

    // decode the payload
    $payload = json_decode(base64_decode($jwt_values[1]), true);
    
    // creating the Base 64 encoded new signature generated by applying the HMAC method to the concatenated header and payload values
    $resultedsignature = base64_encode(hash_hmac('sha256', $recievedHeaderAndPayload, SECRET_KEY, true));
    
    // checking if the created signature is equal to the received signature
    if($resultedsignature == $recieved_signature) {
        // If everything worked fine, if the signature is ok and the payload
        // was not modified return payload
        return $payload;
    }
    
    return false;

}